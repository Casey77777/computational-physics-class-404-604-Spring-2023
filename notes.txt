PROGRAMMING PRINCIPLES

	1. gives correct answer
	2. clear and easy to read code (i.e. it documents itself)
	3. easy to use
	4. built up out of small programs 
	5. easy to modify and robust

	Plan ahead! Use pseudocode if necessary.

PSEUDOCODE

	1. flow chart
	2. small codes
	3. put together
	4. test

EFFICIENT PROGRAM

	Example:

		How to calculate 9^23 efficiently?
			9 x 9 x 9 x ... x 9 = 9^32  (32 products)
			or
			((((9^2)^2)^2)^2)^2 = 9^32  (5 products)

DYNAMIC PROGRAMMING

	Break up a problem into a series of overlapping subproblems. 

	Methods:
		1. Memorization - catch the output of a function and store it 
						  if necessary. 
		2. Tabulation - bottom-up (store all sub-problems)

ABSOLUTE AND RELATIVE ERROR

	y is exact solution
	y_c is experiment/computer
	del = |y - y_c| is absolute error
	del_bar = del / |y| is relative error

	1 = 1 + eps
	y = y(1 + eps)
	  = y + y*eps
	del = |y - y_c|
	    = |y*eps|
	del_bar = del / |y|
	        = eps
	
ERROR OF OPERATION
	
	Sum:

		a,b,c (positive, exact)
		a',b',c' (positive, approximation)

		a = b + c
		b' = b(1 + eps_b)
		c' = c(1 + eps_c)
		a' = b' + c' 
		   = b + c + b*eps_b + c*eps_c
		   <= b + c + (b + c)*max(eps_b,eps_c)
		   = a + a*max(eps_b,eps_c)

		del_bar = |a'-a|/a
				<= max(eps_b,eps_c)

	Difference:

		a = b - c
		a' = b - c + b*eps_b - c*eps_c
		
		del_bar = |a'-a|/a
				= |b*eps_b - c*eps_c| / (b-c)

TRUNCATION ERROR

	1. truncating an infinite series with finite series

		Example:

			sin(x) = taylor_expansion_up_to_N_terms + err(x,N)

	2. discretization (e.g. Euler's method with finite steps)

SOLVING EQUATIONS

	Solving equation of the form f(x) = 0.

	1. Bisection

	2. Newton-Raphson method

		guess x0, f(x0) != 0, correction delta_x

		hoping that f(x0 + delta_x) = 0

		f(x0 + delta_x) is approx. f(x0) + f'(x0)delta_x + ... = 0

		Procedure:
			delta_x = -f(x0) / f'(x0)
			x0 = x0 + delta_x
			repeat

		Multiple Equations:

			Example:
			
				x1^2 + x1*x2 = 10
				x2 + 3*x1*x2^2 = 57

				fi(x1,x2,...,xN) = 0, i = 1,...,N

				vec_f(vec_x) = (f1(x1,x2), f2(x1,x2))
							 = (x1^2 + x1*x2, x2 + 3*x1*x2^2)
							 = (10, 57)

				guess x1, x2; correction delta_x1, delta_x2

				f1(x1+delta_x1, x2+delta_x2) = 0
				f2(x1+delta_x1, x2+delta_x2) = 0

				taylor expand

				f1(x1+delta_x1) ~ f1(x1,x2) + del_f1/del_x1*delta_x1 + 
								  del_f1/del_x2*delta_x2 = 0
				f2(x1+delta_x1) ~ f2(x1,x2) + del_f2/del_x1*delta_x1 + 
								  del_f2/del_x2*delta_x2 = 0

				






